{% extends "base.html" %}

{% block title %}{{ _('Admin - System Backup & Restore') }}{% endblock %}

{% block head_extra %}
{{ super() }}
<style>
    .log-area {
        max-height: 200px;
        overflow-y: auto;
        background: #f0f0f0;
        border: 1px solid #ccc;
        padding: 10px;
        margin-top: 10px;
        white-space: pre-wrap;
        font-family: monospace;
        font-size: 0.9em;
    }
    .log-entry {
        padding: 2px 0;
    }
    .log-error {
        color: red;
        font-weight: bold;
    }
    .log-success {
        color: green;
        font-weight: bold;
    }
    .log-info {
        color: #333;
    }
    /* Styles for DB Records View */
    .db-table-container {
        border: 1px solid #eee;
        padding: 10px;
        border-radius: 4px;
    }
    .db-records-content pre {
        background-color: #f8f9fa; /* Light background for pre */
        padding: 10px;
        border-radius: 4px;
        max-height: 300px; /* Max height for individual record lists */
        overflow-y: auto;
    }
    /* Style for active (expanded) button */
    #view-db-records-output .btn.active {
        background-color: #007bff;
        color: white;
    }
    /* Ensure tab panes have some padding when active */
    .tab-content > .tab-pane { /* This might be less relevant if not using tabs in this specific file */
        padding-top: 1rem;
    }
</style>
{% endblock %}

{% block content %}
<div class="container mt-4">
    <h1>{{ _('System Backup & Restore') }}</h1>
    <hr>
    <p>{{ _('Current Server Time:') }} <span id="utc-clock" data-offset="{{ global_time_offset_hours | default(0) }}">Loading...</span></p>
    <hr>

    <!-- Full System Backup & Restore Card -->
    <div class="card mb-4">
        <div class="card-header">
            <h2 class="card-title h5">{{ _('Full System Backup & Restore') }}</h2>
        </div>
        <div class="card-body">
            <section id="backup-section" class="mb-4">
                <h5>{{ _('One Click Backup') }}</h5>
                <p>{{ _('Perform a full backup of the database, map configurations, and uploaded media files.') }}</p>
                <div class="alert alert-info alert-sm" role="alert">
                    <small><i class="fas fa-info-circle"></i> {{ _('Note: The One Click Backup feature requires Azure Storage to be configured. This includes installing the necessary Python package (azure-storage-file-share) and setting the AZURE_STORAGE_CONNECTION_STRING environment variable.') }}</small>
                </div>
                <button id="one-click-backup-btn" class="btn btn-primary"><i class="fas fa-cloud-upload-alt"></i> {{ _('Perform Full Backup Now') }}</button>
                <div id="backup-status-message" class="mt-2"></div>
            </section>
            <hr>
            <section id="restore-section">
                <h5>{{ _('One Click Restore') }}</h5>
                <p>{{ _('Restore the system from a previously created full backup. This will overwrite current data.') }}</p>
                <button id="list-backups-btn" class="btn btn-info mb-3 me-2"><i class="fas fa-sync-alt"></i> {{ _('Refresh Available Backups') }}</button>
                <button id="bulk-delete-backups-btn" class="btn btn-danger mb-3" style="display: none;"><i class="fas fa-trash-alt"></i> {{ _('Delete Selected Backups') }}</button>
                <div id="restore-status-message" class="mt-2 mb-3"></div>
                <table id="available-backups-table" class="table table-striped">
                    <thead>
                        <tr>
                            <th>{{ _('Backup Timestamp (UTC)') }}</th>
                            <th>{{ _('Actions') }}</th>
                        </tr>
                    </thead>
                    <tbody id="available-backups-tbody"></tbody>
                </table>
                <nav aria-label="Backup pagination" id="backup-pagination-nav" class="mt-3" style="display: none;">
                    <div class="d-flex justify-content-between align-items-center">
                        <div>
                            <label for="system-backups-per-page-select" class="me-2">{{ _('Items per page:') }}</label>
                            <select id="system-backups-per-page-select" class="form-select form-select-sm" style="width: auto; display: inline-block;">
                                <option value="5" selected>5</option>
                                <option value="10">10</option>
                                <option value="25">25</option>
                                <option value="50">50</option>
                            </select>
                        </div>
                        <ul class="pagination mb-0">
                            <li class="page-item" id="backup-prev-page"><a class="page-link" href="#">{{ _('Previous') }}</a></li>
                            <li class="page-item" id="backup-next-page"><a class="page-link" href="#">{{ _('Next') }}</a></li>
                        </ul>
                    </div>
                    <p class="text-center mt-2" id="backup-page-info"></p>
                </nav>
            </section>
        </div>
    </div>

    <!-- Scheduled Full System Backups Card -->
    <div class="card mb-4">
        <div class="card-header">
            <h2 class="card-title h5">{{ _('Scheduled Full System Backups') }}</h2>
        </div>
        <div class="card-body">
            <form method="POST" action="{{ url_for('admin_ui.save_full_backup_schedule_settings') }}" id="full-backup-schedule-form">
                <input type="hidden" name="csrf_token" value="{{ csrf_token() }}"/>
                <div class="form-group mb-2">
                    <div class="form-check">
                        <input type="checkbox" class="form-check-input" id="full_backup_enabled" name="full_backup_enabled" value="true" {% if full_backup_settings.is_enabled %}checked{% endif %}>
                        <label class="form-check-label" for="full_backup_enabled">{{ _('Enable Scheduled Full Backups') }}</label>
                    </div>
                </div>
                <div class="form-group mb-2">
                    <label for="full_backup_schedule_type">{{ _('Schedule Type') }}</label>
                    <select id="full_backup_schedule_type" name="full_backup_schedule_type" class="form-control form-select">
                        <option value="daily" {% if full_backup_settings.schedule_type == 'daily' %}selected{% endif %}>{{ _('Daily') }}</option>
                        <option value="weekly" {% if full_backup_settings.schedule_type == 'weekly' %}selected{% endif %}>{{ _('Weekly') }}</option>
                        <option value="interval" {% if full_backup_settings.schedule_type == 'interval' %}selected{% endif %}>{{ _('Interval') }}</option>
                    </select>
                </div>

                <!-- Fields for Daily/Weekly -->
                <div id="cron-based-schedule-fields">
                    <div class="form-group mb-2" id="day-of-week-group" {% if full_backup_settings.schedule_type != 'weekly' %}style="display: none;"{% endif %}>
                        <label for="full_backup_day_of_week">{{ _('Day of Week') }}</label>
                        <select id="full_backup_day_of_week" name="full_backup_day_of_week" class="form-control form-select">
                            <option value="0" {% if full_backup_settings.day_of_week == 0 %}selected{% endif %}>{{ _('Monday') }}</option>
                            <option value="1" {% if full_backup_settings.day_of_week == 1 %}selected{% endif %}>{{ _('Tuesday') }}</option>
                            <option value="2" {% if full_backup_settings.day_of_week == 2 %}selected{% endif %}>{{ _('Wednesday') }}</option>
                            <option value="3" {% if full_backup_settings.day_of_week == 3 %}selected{% endif %}>{{ _('Thursday') }}</option>
                            <option value="4" {% if full_backup_settings.day_of_week == 4 %}selected{% endif %}>{{ _('Friday') }}</option>
                            <option value="5" {% if full_backup_settings.day_of_week == 5 %}selected{% endif %}>{{ _('Saturday') }}</option>
                            <option value="6" {% if full_backup_settings.day_of_week == 6 %}selected{% endif %}>{{ _('Sunday') }}</option>
                        </select>
                    </div>
                    <div class="form-group mb-2" id="time-of-day-group">
                        <label for="full_backup_time_of_day">{{ _('Time of Day (UTC)') }}</label>
                        <input type="time" id="full_backup_time_of_day" name="full_backup_time_of_day" class="form-control" value="{{ full_backup_settings.time_of_day | default('02:00') }}">
                    </div>
                </div>

                <!-- Fields for Interval -->
                <div id="interval-based-schedule-fields" {% if full_backup_settings.schedule_type != 'interval' %}style="display: none;"{% endif %}>
                    <div class="form-group mb-2" id="interval-value-group">
                        <label for="full_backup_interval_value">{{ _('Interval Value') }}</label>
                        <input type="number" id="full_backup_interval_value" name="full_backup_interval_value" class="form-control" value="{{ full_backup_settings.interval_value | default(60) }}" min="1">
                        <small class="form-text text-muted">{{ _('Enter a positive integer (e.g., 30 for 30 minutes/hours).') }}</small>
                    </div>
                    <div class="form-group mb-2" id="interval-unit-group">
                        <label for="full_backup_interval_unit">{{ _('Interval Unit') }}</label>
                        <select id="full_backup_interval_unit" name="full_backup_interval_unit" class="form-control form-select">
                            <option value="minutes" {% if full_backup_settings.interval_unit == 'minutes' %}selected{% endif %}>{{ _('Minutes') }}</option>
                            <option value="hours" {% if full_backup_settings.interval_unit == 'hours' %}selected{% endif %}>{{ _('Hours') }}</option>
                        </select>
                    </div>
                </div>
                <button type="submit" class="btn btn-success mt-3"><i class="fas fa-save"></i> {{ _('Save Full Backup Schedule') }}</button>
            </form>
        </div>
    </div>

    <!-- Global Log Areas -->
    <div class="mt-4">
        <h5>{{ _('Operation Logs') }}</h5>
        <pre id="backup-log-area" class="log-area" style="display: none;"></pre>
        <pre id="restore-log-area" class="log-area" style="display: none;"></pre>
    </div>

    <!-- Selective Restore Modal (remains global as it's triggered from here) -->
    <div id="selective-restore-modal" class="modal" style="display: none !important;">
        <div class="modal-content">
            <span class="close-modal-btn" id="close-selective-restore-modal">&times;</span>
            <h3>{{ _('Selective Restore Options') }}</h3>
            <p>{{ _('Select components to restore for backup:') }} <strong id="modal-backup-timestamp"></strong></p>
            <form id="selective-restore-form">
                <div class="form-check">
                    <input class="form-check-input component-checkbox" type="checkbox" value="database" id="component-database" name="components">
                    <label class="form-check-label" for="component-database">{{ _('Database (Bookings, Users, Resources, etc.)') }}</label>
                </div>
                <div class="form-check">
                    <input class="form-check-input component-checkbox" type="checkbox" value="map_config" id="component-map_config" name="components">
                    <label class="form-check-label" for="component-map_config">{{ _('Map Configuration (Floor map definitions & resource mappings on maps)') }}</label>
                </div>
                <div class="form-check">
                    <input class="form-check-input component-checkbox" type="checkbox" value="floor_maps" id="component-floor_maps" name="components">
                    <label class="form-check-label" for="component-floor_maps">{{ _('Floor Map Images (in static/floor_map_uploads)') }}</label>
                </div>
                <div class="form-check">
                    <input class="form-check-input component-checkbox" type="checkbox" value="resource_uploads" id="component-resource_uploads" name="components">
                    <label class="form-check-label" for="component-resource_uploads">{{ _('Resource Images (in static/resource_uploads)') }}</label>
                </div>
                <hr>
                <div class="form-check">
                    <input class="form-check-input" type="checkbox" value="all" id="component-all" name="components_all">
                    <label class="form-check-label" for="component-all">{{ _('ALL COMPONENTS (Full Restore)') }}</label>
                </div>
                <button type="submit" id="confirm-selective-restore-btn" class="btn btn-primary mt-3">{{ _('Proceed with Selected Restore') }}</button>
            </form>
            <div id="selective-restore-modal-status" class="status-message mt-2"></div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
    {{ super() }}
    {# admin_backup_common.js now includes polling logic, disable/enable interactions, appendLog, and UTC clock #}
    <script src="{{ url_for('static', filename='js/admin_backup_common.js') }}" defer></script>
    {# NEW: Added event listener for restore dry run functionality #}
    <script src="{{ url_for('static', filename='js/restore_dry_run_event_listener.js') }}" defer></script>
    <script>
        document.addEventListener('DOMContentLoaded', function () {
            const csrfToken = document.querySelector('meta[name="csrf-token"]').getAttribute('content');

            // Element Variable Definitions for System Backup & Restore
            const backupButton = document.getElementById('one-click-backup-btn');
            const backupStatusMessageEl = document.getElementById('backup-status-message');
            const backupLogAreaEl = document.getElementById('backup-log-area'); // Used by appendLog

            const listBackupsButton = document.getElementById('list-backups-btn');
            const restoreStatusMessageEl = document.getElementById('restore-status-message');
            const restoreLogAreaEl = document.getElementById('restore-log-area'); // Used by appendLog

            const availableBackupsTbody = document.getElementById('available-backups-tbody');
            const availableBackupsTable = document.getElementById('available-backups-table');
            const bulkDeleteButton = document.getElementById('bulk-delete-backups-btn');
            const masterBackupCheckbox = document.getElementById('master-backup-checkbox');

            const paginationNav = document.getElementById('backup-pagination-nav');
            const pageInfoEl = document.getElementById('backup-page-info');
            const prevPageBtn = document.getElementById('backup-prev-page');
            const nextPageBtn = document.getElementById('backup-next-page');
            const systemBackupsPerPageSelect = document.getElementById('system-backups-per-page-select');

            // Selective Restore Modal Elements
            const selectiveRestoreModal = document.getElementById('selective-restore-modal');
            const closeModalBtn = document.getElementById('close-selective-restore-modal');
            const modalBackupTimestampEl = document.getElementById('modal-backup-timestamp');
            const selectiveRestoreForm = document.getElementById('selective-restore-form');
            // const confirmSelectiveRestoreBtn = document.getElementById('confirm-selective-restore-btn'); // Handled by form submit
            const selectiveRestoreModalStatusEl = document.getElementById('selective-restore-modal-status');
            const componentCheckboxes = document.querySelectorAll('#selective-restore-form input[name="components"]');
            const componentAllCheckbox = document.getElementById('component-all');

            // Scheduled Full Backup Form Elements
            const fullBackupScheduleTypeSelect = document.getElementById('full_backup_schedule_type');
            const dayOfWeekGroup = document.getElementById('day-of-week-group');

            // Task ID variables (managed by admin_backup_common.js or locally if needed for specific logic)
            // let currentBackupTaskId = null; // These are now in admin_backup_common.js if made global there
            // let currentRestoreTaskId = null; // For one-click full restore (not yet refactored here)
            // let currentSelectiveRestoreTaskId = null; // For selective restore
            // let currentVerifyTaskId = null;
            // let currentDeleteTaskId = null;
            // let currentBulkDeleteTaskId = null;
            // let currentDryRunTaskId = null; // Added for dry run

            // Pagination Variables for System Backups
            let currentSystemBackupsPage = 1;
            let systemBackupsPerPage = 5;
            let totalSystemBackupItems = 0;
            let totalSystemBackupPages = 0;
            let hasSystemBackupPrev = false;
            let hasSystemBackupNext = false;

            // --- Event Handlers & Functions ---

            // One-Click Full System Backup
            if (backupButton) {
                backupButton.addEventListener('click', function () {
                    if (currentBackupTaskId && activePolls[currentBackupTaskId]) {
                        appendLog('backup-log-area', "{{ _('A backup operation is already in progress.') }}", "", "warning", backupStatusMessageEl);
                        return;
                    }
                    disablePageInteractions();
                    if (backupLogAreaEl) backupLogAreaEl.innerHTML = '';
                    if (restoreLogAreaEl && restoreLogAreaEl.style.display !== 'none') restoreLogAreaEl.style.display = 'none'; // Hide other log
                    appendLog('backup-log-area', "{{ _('Initiating full system backup request...') }}", '', 'info', backupStatusMessageEl);

                    fetch('/api/admin/one_click_backup', {
                        method: 'POST',
                        headers: { 'X-CSRFToken': csrfToken, 'Accept': 'application/json', 'Content-Type': 'application/json' },
                        body: JSON.stringify({})
                    })
                    .then(response => response.json())
                    .then(data => {
                        const messageType = data.success ? 'info' : 'error';
                        appendLog('backup-log-area', data.message || (data.success ? "{{ _('Backup task started.') }}" : "{{ _('Failed to start backup task.') }}"), `Task ID: ${data.task_id || 'N/A'}`, messageType, backupStatusMessageEl);

                        if (data.success && data.task_id) {
                            currentBackupTaskId = data.task_id;
                            displayedLogCounts[currentBackupTaskId] = 0;
                            if (activePolls[currentBackupTaskId]) clearInterval(activePolls[currentBackupTaskId]);
                            activePolls[currentBackupTaskId] = setInterval(() => {
                                pollTaskStatus(currentBackupTaskId, 'backup-log-area', backupStatusMessageEl, 'full_system_backup');
                            }, POLLING_INTERVAL_MS);
                        } else {
                            enablePageInteractions();
                        }
                    })
                    .catch(error => {
                        console.error('Full system backup request error:', error);
                        appendLog('backup-log-area', "{{ _('Full system backup request failed:') }}", error.message, 'error', backupStatusMessageEl);
                        enablePageInteractions();
                    });
                });
            }

            // Selective Restore Form Submission
            if (selectiveRestoreForm) {
                selectiveRestoreForm.addEventListener('submit', function(event) {
                    event.preventDefault();
                    if (currentSelectiveRestoreTaskId && activePolls[currentSelectiveRestoreTaskId]) {
                         appendLog('restore-log-area', "{{ _('A selective restore operation is already in progress.') }}", "", "warning", selectiveRestoreModalStatusEl);
                         return;
                    }

                    const backupTimestamp = this.dataset.timestamp;
                    const selectedComponents = Array.from(document.querySelectorAll('#selective-restore-form input[name="components"]:checked')).map(cb => cb.value);

                    // Retain the check for no components selected first.
                    if (selectedComponents.length === 0) {
                        if (selectiveRestoreModalStatusEl) {
                            selectiveRestoreModalStatusEl.textContent = "{{ _('Please select at least one component to restore.') }}";
                            selectiveRestoreModalStatusEl.className = 'alert alert-warning mt-2';
                        }
                        return;
                    }

                    // New: Display informational message that this is a simulation
                    // This message will appear in the modal.
                    if (selectiveRestoreModalStatusEl) {
                        selectiveRestoreModalStatusEl.textContent = "{{ _('Note: This will run a *simulation* of restoring the selected components. No live data will be changed. Actual restore functionality will be implemented separately.') }}";
                        selectiveRestoreModalStatusEl.className = 'alert alert-info mt-2';
                    }

                    // The previous logic for blocking "full restore" has been removed as per new instructions.
                    // The form will now proceed to simulate for any valid selection.

                    disablePageInteractions(); // Disable interactions on main page
                    if(restoreLogAreaEl) { restoreLogAreaEl.innerHTML = ''; restoreLogAreaEl.style.display = 'block'; }
                    if(backupLogAreaEl && backupLogAreaEl.style.display !== 'none') backupLogAreaEl.style.display = 'none';

                    // The main page log and status will indicate the start of the operation.
                    // The modal message (set above) will remain visible until the task starts successfully and closes the modal,
                    // or if an error occurs before then.
                    appendLog('restore-log-area', `{{ _('Initiating selective restore simulation for') }} ${backupTimestamp}...`, `Components: ${selectedComponents.join(', ')}`, 'info', restoreStatusMessageEl);
                    // No longer setting modal status to "Processing..." here, let the info message persist longer.
                    // selectiveRestoreModalStatusEl.textContent = "{{ _('Processing...') }}";
                    // selectiveRestoreModalStatusEl.className = 'alert alert-info mt-2';


                    fetch('/api/admin/selective_restore', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken, 'Accept': 'application/json' },
                        body: JSON.stringify({ backup_timestamp: backupTimestamp, components: selectedComponents })
                    })
                    .then(response => response.json())
                    .then(data => {
                        const messageType = data.success ? 'info' : 'error';
                        // Log to main page's restore log area
                        appendLog('restore-log-area', data.message || (data.success ? `{{ _('Selective restore task for ${backupTimestamp} started.') }}` : `{{ _('Failed to start selective restore for ${backupTimestamp}.') }}`), `Task ID: ${data.task_id || 'N/A'}`, messageType, restoreStatusMessageEl);

                        // Update modal status
                        selectiveRestoreModalStatusEl.textContent = data.message;
                        selectiveRestoreModalStatusEl.className = `alert alert-${messageType} mt-2`;

                        if (data.success && data.task_id) {
                            if(selectiveRestoreModal) selectiveRestoreModal.style.display = 'none'; // Close modal on successful start
                            currentSelectiveRestoreTaskId = data.task_id;
                            displayedLogCounts[currentSelectiveRestoreTaskId] = 0;
                            if (activePolls[currentSelectiveRestoreTaskId]) clearInterval(activePolls[currentSelectiveRestoreTaskId]);
                            activePolls[currentSelectiveRestoreTaskId] = setInterval(() => {
                                pollTaskStatus(currentSelectiveRestoreTaskId, 'restore-log-area', restoreStatusMessageEl, 'selective_restore');
                            }, POLLING_INTERVAL_MS);
                        } else {
                            enablePageInteractions(); // Re-enable if task start failed
                        }
                    })
                    .catch(error => {
                        console.error('Selective restore error:', error);
                        const errorMsg = `{{ _('Selective restore request for ${backupTimestamp} failed:') }} ${error.toString()}`;
                        appendLog('restore-log-area', errorMsg, '', 'error', restoreStatusMessageEl);
                        selectiveRestoreModalStatusEl.textContent = errorMsg;
                        selectiveRestoreModalStatusEl.className = 'alert alert-danger mt-2';
                        enablePageInteractions();
                    });
                });
            }

            // Delegated event listener for buttons inside availableBackupsTable
            if(availableBackupsTable) {
                availableBackupsTable.addEventListener('click', function (event) {
                    const targetButton = event.target.closest('button');
                    if (!targetButton) return;

                    const timestamp = targetButton.getAttribute('data-timestamp');
                    let displayTimestamp = timestamp;
                     try { // Format timestamp for display
                        const year = timestamp.substring(0,4); const month = timestamp.substring(4,6);
                        const day = timestamp.substring(6,8); const hour = timestamp.substring(9,11);
                        const minute = timestamp.substring(11,13); const second = timestamp.substring(13,15);
                        displayTimestamp = `${year}-${month}-${day} ${hour}:${minute}:${second}`;
                    } catch (e) { /* ignore, use raw timestamp */ }

                    let operationType = null;
                    let currentOperationTaskIdVariable = null; // To hold var name like 'currentVerifyTaskId'
                    let endpoint = '';
                    let confirmationMessage = '';
                    let method = 'POST';
                    let body = {};
                    let logArea = 'restore-log-area';
                    let statusEl = restoreStatusMessageEl;

                    if (targetButton.classList.contains('restore-btn')) { // Opens selective restore modal
                        if(modalBackupTimestampEl) modalBackupTimestampEl.textContent = displayTimestamp;
                        if(selectiveRestoreForm) selectiveRestoreForm.dataset.timestamp = timestamp;
                        if(componentCheckboxes) componentCheckboxes.forEach(cb => cb.checked = true);
                        if(componentAllCheckbox) componentAllCheckbox.checked = true;
                        if(selectiveRestoreModalStatusEl) selectiveRestoreModalStatusEl.textContent = '';
                        if(selectiveRestoreModalStatusEl) selectiveRestoreModalStatusEl.className = 'status-message mt-2';
                        if(selectiveRestoreModal) selectiveRestoreModal.style.display = 'block';
                        return; // Modal handles its own submission
                    // REMOVED: Conflicting restore-dry-run-btn handler. This is now in restore_dry_run_event_listener.js
                    // } else if (targetButton.classList.contains('restore-dry-run-btn')) {
                    //     // This was not refactored in API to be async, assuming it's quick or will be
                    //     // For now, keep its original synchronous-like fetch, or refactor API if it's long
                    //     console.warn("Dry run not yet fully refactored for polling in this UI example.");
                    //     // If it were async: operationType = 'restore_dry_run'; currentOperationTaskIdVariable = 'currentDryRunTaskId';
                    //     // endpoint = `/api/admin/restore_dry_run/${timestamp}`; // Needs task_id return from API
                    //     // For now, it might be better to leave the old sync logic or simplify
                    //     alert("Dry run functionality needs UI update for async tasks if it's long running.");
                    //     return;
                    } else if (targetButton.classList.contains('verify-backup-btn-js')) {
                        operationType = 'verify_backup';
                        currentOperationTaskIdVariable = 'currentVerifyTaskId'; // String name of var
                        endpoint = '/api/admin/verify_backup';
                        confirmationMessage = `{{ _('Are you sure you want to verify backup') }} ${displayTimestamp}?`;
                        body = { backup_timestamp: timestamp };
                    } else if (targetButton.classList.contains('delete-backup-btn')) {
                        operationType = 'delete_backup_set';
                        currentOperationTaskIdVariable = 'currentDeleteTaskId';
                        endpoint = `/api/admin/delete_backup/${timestamp}`; // Timestamp in URL for this one
                        confirmationMessage = `{{ _('Are you sure you want to delete backup') }} '${displayTimestamp}'? {{ _('This action cannot be undone.') }}`;
                        body = {}; // No body needed if timestamp in URL
                    } else {
                        return; // Not a button we handle here
                    }

                    if (window[currentOperationTaskIdVariable] && activePolls[window[currentOperationTaskIdVariable]]) {
                         appendLog(logArea, `{{ _('An operation of type') }} '${operationType}' {{ _('is already in progress.') }}`, "", "warning", statusEl);
                         return;
                    }

                    if (!confirm(confirmationMessage)) return;

                    disablePageInteractions();
                    if(document.getElementById(logArea)) document.getElementById(logArea).innerHTML = '';
                    if (logArea === 'restore-log-area' && backupLogAreaEl && backupLogAreaEl.style.display !== 'none') backupLogAreaEl.style.display = 'none';
                    else if (logArea === 'backup-log-area' && restoreLogAreaEl && restoreLogAreaEl.style.display !== 'none') restoreLogAreaEl.style.display = 'none';

                    appendLog(logArea, `{{ _('Initiating') }} ${operationType.replace(/_/g, ' ')} {{ _('for') }} ${displayTimestamp}...`, '', 'info', statusEl);

                    fetch(endpoint, {
                        method: 'POST', // All these are POST
                        headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken, 'Accept': 'application/json' },
                        body: JSON.stringify(body)
                    })
                    .then(response => response.json())
                    .then(data => {
                        const messageType = data.success ? 'info' : 'error';
                        appendLog(logArea, data.message || `{{ _('Task for') }} ${operationType} {{ _('started.') }}`, `Task ID: ${data.task_id || 'N/A'}`, messageType, statusEl);
                        if (data.success && data.task_id) {
                            window[currentOperationTaskIdVariable] = data.task_id; // e.g. currentVerifyTaskId = data.task_id
                            displayedLogCounts[data.task_id] = 0;
                            if (activePolls[data.task_id]) clearInterval(activePolls[data.task_id]);
                            activePolls[data.task_id] = setInterval(() => {
                                pollTaskStatus(data.task_id, logArea, statusEl, operationType);
                            }, POLLING_INTERVAL_MS);
                        } else {
                            enablePageInteractions();
                        }
                    })
                    .catch(error => {
                        console.error(`${operationType} request error:`, error);
                        appendLog(logArea, `{{ _('Request for') }} ${operationType} {{ _('failed:') }}`, error.message, 'error', statusEl);
                        enablePageInteractions();
                    });
                });
            }

            // Bulk Delete Backups
            if (bulkDeleteButton) {
                bulkDeleteButton.addEventListener('click', function() {
                    if (currentBulkDeleteTaskId && activePolls[currentBulkDeleteTaskId]) {
                        appendLog('restore-log-area', "{{ _('A bulk delete operation is already in progress.') }}", "", "warning", restoreStatusMessageEl);
                        return;
                    }
                    const selectedTimestamps = Array.from(availableBackupsTbody.querySelectorAll('.backup-checkbox:checked'))
                                                 .map(cb => cb.getAttribute('data-timestamp'));
                    if (selectedTimestamps.length === 0) {
                        alert("{{ _('Please select at least one backup to delete.') }}");
                        return;
                    }
                    if (!confirm(`{{ _('Are you sure you want to delete the selected ${selectedTimestamps.length} backup(s)? This action cannot be undone.') }}`)) {
                        return;
                    }
                    disablePageInteractions();
                    if(restoreLogAreaEl) restoreLogAreaEl.innerHTML = '';
                    if(backupLogAreaEl && backupLogAreaEl.style.display !== 'none') backupLogAreaEl.style.display = 'none';
                    appendLog('restore-log-area', `{{ _('Initiating bulk deletion for ${selectedTimestamps.length} backup(s)...') }}`, '', 'info', restoreStatusMessageEl);

                    fetch('/api/admin/bulk_delete_system_backups', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken, 'Accept': 'application/json' },
                        body: JSON.stringify({ timestamps: selectedTimestamps })
                    })
                    .then(response => response.json())
                    .then(data => {
                        const messageType = data.success ? 'info' : 'error';
                        appendLog('restore-log-area', data.message || `{{ _('Bulk deletion task started.') }}`, `Task ID: ${data.task_id || 'N/A'}`, messageType, restoreStatusMessageEl);
                        if (data.success && data.task_id) {
                            currentBulkDeleteTaskId = data.task_id;
                            displayedLogCounts[currentBulkDeleteTaskId] = 0;
                            if (activePolls[currentBulkDeleteTaskId]) clearInterval(activePolls[currentBulkDeleteTaskId]);
                            activePolls[currentBulkDeleteTaskId] = setInterval(() => {
                                pollTaskStatus(currentBulkDeleteTaskId, 'restore-log-area', restoreStatusMessageEl, 'bulk_delete_system_backups');
                            }, POLLING_INTERVAL_MS);
                        } else {
                            enablePageInteractions();
                        }
                    })
                    .catch(error => {
                        console.error('Bulk delete request error:', error);
                        appendLog('restore-log-area', "{{ _('Bulk delete request failed:') }}", error.message, 'error', restoreStatusMessageEl);
                        enablePageInteractions();
                    });
                });
            }

            // --- Functions for loading and displaying backups (largely unchanged but ensure they call enablePageInteractions) ---
            function loadAvailableBackups(page = 1, perPage = systemBackupsPerPage, isQuickRefresh = false) {
                currentSystemBackupsPage = page;
                systemBackupsPerPage = perPage;
                if (!isQuickRefresh) disablePageInteractions();
                appendLog('restore-log-area', `{{ _('Fetching available full system backups (Page: ${page}, Per Page: ${perPage})...') }}`, '', 'info', restoreStatusMessageEl);
                const colCount = availableBackupsTable.querySelector('thead tr') ? availableBackupsTable.querySelector('thead tr').cells.length : 3;
                if(availableBackupsTbody) availableBackupsTbody.innerHTML = `<tr><td colspan="${colCount}">{{ _("Loading...") }}</td></tr>`;
                if(paginationNav) paginationNav.style.display = 'none';

                fetch(`/api/admin/list_backups?page=${currentSystemBackupsPage}&per_page=${systemBackupsPerPage}`, {
                    method: 'GET', headers: { 'Accept': 'application/json' }
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success && data.backups) {
                        currentSystemBackupsPage = data.page; systemBackupsPerPage = data.per_page;
                        totalSystemBackupItems = data.total_items; totalSystemBackupPages = data.total_pages;
                        hasSystemBackupPrev = data.has_prev; hasSystemBackupNext = data.has_next;
                        displayBackupsPage(data.backups);
                        appendLog('restore-log-area', totalSystemBackupItems > 0 ? "{{ _('Available full system backups loaded.') }}" : "{{ _('No full system backups found.') }}", totalSystemBackupItems > 0 ? `Total: ${totalSystemBackupItems}` : '', totalSystemBackupItems > 0 ? 'success' : 'info', restoreStatusMessageEl);
                    } else {
                        totalSystemBackupItems = 0; totalSystemBackupPages = 0; hasSystemBackupPrev = false; hasSystemBackupNext = false;
                        if(availableBackupsTbody) availableBackupsTbody.innerHTML = `<tr><td colspan="${colCount}">{{ _("Failed to load backups.") }}</td></tr>`;
                        appendLog('restore-log-area', "{{ _('Failed to load full system backups:') }}", data.message || "{{ _('Unknown error.') }}", 'error', restoreStatusMessageEl);
                        if(paginationNav) paginationNav.style.display = 'none';
                    }
                })
                .catch(error => {
                    totalSystemBackupItems = 0; totalSystemBackupPages = 0; hasSystemBackupPrev = false; hasSystemBackupNext = false;
                    console.error('List backups error:', error);
                    if(availableBackupsTbody) availableBackupsTbody.innerHTML = `<tr><td colspan="${colCount}">{{ _("Error loading backups.") }}</td></tr>`;
                    appendLog('restore-log-area', "{{ _('Error fetching full system backups:') }}", error.toString(), 'error', restoreStatusMessageEl);
                    if(paginationNav) paginationNav.style.display = 'none';
                })
                .finally(() => { if (!isQuickRefresh) enablePageInteractions(); });
            }

            function displayBackupsPage(pageBackups) {
                if (!availableBackupsTbody) return;
                availableBackupsTbody.innerHTML = '';
                const tableHeaderRow = availableBackupsTable.querySelector('thead tr');
                if (tableHeaderRow && tableHeaderRow.cells.length === 2) {
                    const thMaster = document.createElement('th');
                    thMaster.innerHTML = '<input type="checkbox" id="master-backup-checkbox" title="{{ _("Select/Deselect All") }}">';
                    tableHeaderRow.insertBefore(thMaster, tableHeaderRow.firstChild);
                }
                const colCount = availableBackupsTable.querySelector('thead tr') ? availableBackupsTable.querySelector('thead tr').cells.length : 3;

                if (!pageBackups || pageBackups.length === 0) {
                    availableBackupsTbody.innerHTML = `<tr><td colspan="${colCount}">{{ _("No backups available for this page.") }}</td></tr>`;
                    if(paginationNav) paginationNav.style.display = totalSystemBackupPages > 0 ? 'block' : 'none';
                    if(bulkDeleteButton) bulkDeleteButton.style.display = totalSystemBackupItems > 0 ? 'inline-block' : 'none';
                    if(masterBackupCheckbox) { masterBackupCheckbox.checked = false; masterBackupCheckbox.disabled = true; }
                    if (totalSystemBackupItems === 0 && bulkDeleteButton) bulkDeleteButton.style.display = 'none';
                } else {
                     if(bulkDeleteButton) bulkDeleteButton.style.display = 'inline-block';
                     if(masterBackupCheckbox) masterBackupCheckbox.disabled = false;
                }

                pageBackups.forEach(timestamp => {
                    const row = availableBackupsTbody.insertRow();
                    const cellCheckbox = row.insertCell();
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox'; checkbox.className = 'backup-checkbox'; checkbox.setAttribute('data-timestamp', timestamp);
                    cellCheckbox.appendChild(checkbox);
                    const cellTimestamp = row.insertCell(); const cellAction = row.insertCell();
                    let displayTimestamp = timestamp;
                    try { const year = timestamp.substring(0,4); const month = timestamp.substring(4,6); const day = timestamp.substring(6,8); const hour = timestamp.substring(9,11); const minute = timestamp.substring(11,13); const second = timestamp.substring(13,15); displayTimestamp = `${year}-${month}-${day} ${hour}:${minute}:${second}`; } catch (e) { /* ignore */ }
                    cellTimestamp.textContent = displayTimestamp;
                    const restoreBtn = document.createElement('button'); restoreBtn.textContent = "{{ _('Restore') }}"; restoreBtn.className = 'btn btn-sm btn-warning restore-btn me-2'; restoreBtn.setAttribute('data-timestamp', timestamp); cellAction.appendChild(restoreBtn);
                    const dryRunBtn = document.createElement('button'); dryRunBtn.textContent = "{{ _('Dry Run') }}"; dryRunBtn.className = 'btn btn-sm btn-info restore-dry-run-btn me-2'; dryRunBtn.setAttribute('data-timestamp', timestamp); cellAction.appendChild(dryRunBtn);
                    const verifyBtnJs = document.createElement('button'); verifyBtnJs.type = 'button'; verifyBtnJs.className = 'btn btn-info btn-sm verify-backup-btn-js'; verifyBtnJs.innerHTML = '<i class="fas fa-check-circle"></i> {{ _("Verify") }}'; verifyBtnJs.setAttribute('data-timestamp', timestamp); verifyBtnJs.style.marginLeft = '5px'; cellAction.appendChild(verifyBtnJs);
                    const deleteBtn = document.createElement('button'); deleteBtn.textContent = "{{ _('Delete') }}"; deleteBtn.className = 'btn btn-sm btn-danger delete-backup-btn'; deleteBtn.style.marginLeft = '5px'; deleteBtn.setAttribute('data-timestamp', timestamp); cellAction.appendChild(deleteBtn);
                });

                if (totalSystemBackupPages > 0) {
                    if(paginationNav) paginationNav.style.display = 'block';
                    if(pageInfoEl) pageInfoEl.textContent = `{{ _('Page') }} ${currentSystemBackupsPage} {{ _('of') }} ${totalSystemBackupPages}`;
                    if(prevPageBtn) prevPageBtn.classList.toggle('disabled', !hasSystemBackupPrev);
                    if(nextPageBtn) nextPageBtn.classList.toggle('disabled', !hasSystemBackupNext);
                } else {
                    if(paginationNav) paginationNav.style.display = 'none';
                }
                updateMasterCheckboxState();
            }

            function updateMasterCheckboxState() { /* ... (unchanged from provided) ... */
                if (!masterBackupCheckbox) return;
                const visibleCheckboxes = Array.from(availableBackupsTbody.querySelectorAll('.backup-checkbox'));
                if (visibleCheckboxes.length === 0) {
                    masterBackupCheckbox.checked = false; masterBackupCheckbox.indeterminate = false; masterBackupCheckbox.disabled = true;
                    if(bulkDeleteButton) bulkDeleteButton.disabled = true; return;
                }
                masterBackupCheckbox.disabled = false;
                const allChecked = visibleCheckboxes.every(cb => cb.checked);
                const someChecked = visibleCheckboxes.some(cb => cb.checked);
                masterBackupCheckbox.checked = allChecked; masterBackupCheckbox.indeterminate = !allChecked && someChecked;
                if(bulkDeleteButton) bulkDeleteButton.disabled = !someChecked;
            }

            if (masterBackupCheckbox) masterBackupCheckbox.addEventListener('change', function() { /* ... (unchanged) ... */
                const isChecked = this.checked;
                availableBackupsTbody.querySelectorAll('.backup-checkbox').forEach(cb => { cb.checked = isChecked; });
                updateMasterCheckboxState();
            });
            if (availableBackupsTbody) availableBackupsTbody.addEventListener('change', function(event) { /* ... (unchanged) ... */
                if (event.target.classList.contains('backup-checkbox')) updateMasterCheckboxState();
            });
            if(listBackupsButton) listBackupsButton.addEventListener('click', function() { loadAvailableBackups(1, systemBackupsPerPage, false); });
            if(prevPageBtn) prevPageBtn.addEventListener('click', function(e) { e.preventDefault(); if (hasSystemBackupPrev) loadAvailableBackups(currentSystemBackupsPage - 1, systemBackupsPerPage); });
            if(nextPageBtn) nextPageBtn.addEventListener('click', function(e) { e.preventDefault(); if (hasSystemBackupNext) loadAvailableBackups(currentSystemBackupsPage + 1, systemBackupsPerPage); });
            if (systemBackupsPerPageSelect) {
                systemBackupsPerPageSelect.value = systemBackupsPerPage;
                systemBackupsPerPageSelect.addEventListener('change', function() { const newPerPage = parseInt(this.value, 10); if (!isNaN(newPerPage) && newPerPage > 0) { systemBackupsPerPage = newPerPage; loadAvailableBackups(1, systemBackupsPerPage); }});
            }

            // Modal Interaction Logic (unchanged)
            if(closeModalBtn) closeModalBtn.addEventListener('click', function() { if(selectiveRestoreModal) selectiveRestoreModal.style.display = 'none'; });
            window.addEventListener('click', function(event) { if (event.target == selectiveRestoreModal) selectiveRestoreModal.style.display = 'none'; });
            if(componentAllCheckbox) componentAllCheckbox.addEventListener('change', function() { if(componentCheckboxes) componentCheckboxes.forEach(cb => cb.checked = this.checked); });
            if(componentCheckboxes) componentCheckboxes.forEach(cb => { cb.addEventListener('change', function() { if (!this.checked && componentAllCheckbox) componentAllCheckbox.checked = false; else { const allChecked = Array.from(componentCheckboxes).every(indCb => indCb.checked); if (allChecked && componentAllCheckbox) componentAllCheckbox.checked = true; }}); });

            // Scheduled Full Backup form visibility logic (unchanged)
            const timeOfDayGroup = document.getElementById('time-of-day-group');
            const intervalValueGroup = document.getElementById('interval-value-group');
            const intervalUnitGroup = document.getElementById('interval-unit-group');
            const cronFieldsContainer = document.getElementById('cron-based-schedule-fields');
            const intervalFieldsContainer = document.getElementById('interval-based-schedule-fields');
            function updateScheduleFieldVisibility() { /* ... (unchanged) ... */
                const scheduleType = fullBackupScheduleTypeSelect.value;
                if (cronFieldsContainer) cronFieldsContainer.style.display = (scheduleType === 'daily' || scheduleType === 'weekly') ? 'block' : 'none';
                if (intervalFieldsContainer) intervalFieldsContainer.style.display = (scheduleType === 'interval') ? 'block' : 'none';
                if (dayOfWeekGroup) dayOfWeekGroup.style.display = (scheduleType === 'weekly') ? 'block' : 'none';
                const timeInput = document.getElementById('full_backup_time_of_day'); if (timeInput) timeInput.required = (scheduleType === 'daily' || scheduleType === 'weekly');
                const intervalValueInput = document.getElementById('full_backup_interval_value'); if(intervalValueInput) intervalValueInput.required = (scheduleType === 'interval');
            }
            if (fullBackupScheduleTypeSelect) { fullBackupScheduleTypeSelect.addEventListener('change', updateScheduleFieldVisibility); updateScheduleFieldVisibility(); }

            // Initial Calls
            if(typeof loadAvailableBackups === "function") loadAvailableBackups(1, systemBackupsPerPage);
            updateMasterCheckboxState();
        });
    </script>
{% endblock %}
