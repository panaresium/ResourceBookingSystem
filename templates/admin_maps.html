{% extends "base.html" %}

{% block title %}{{ _('Admin - Floor Maps - Smart Resource Booking') }}{% endblock %}

{% block content %}
    <h1>{{ _('Floor Map Management') }}</h1>

    <section id="upload-map-section">
        <h2>{{ _('Upload New Floor Map') }}</h2>
        <form id="upload-map-form">
            <input type="hidden" name="csrf_token" value="{{ csrf_token() }}">
            <div>
                <label for="map-name">{{ _('Map Name:') }}</label>
                <input type="text" id="map-name" name="map_name" required>
            </div>
            <div>
                <label for="map-location">{{ _('Location:') }}</label>
                <input type="text" id="map-location" name="location">
            </div>
            <div>
                <label for="map-floor">{{ _('Floor:') }}</label>
                <input type="text" id="map-floor" name="floor">
            </div>
            <div>
                <label for="map-image">{{ _('Map Image File:') }}</label>
                <input type="file" id="map-image" name="map_image" accept="image/png, image/jpeg" required>
            </div>
            <div>
                <label for="map_offset_x">{{ _('Offset X (px):') }}</label>
                <input type="number" id="map_offset_x" name="offset_x" value="0" style="width: 80px;">
            </div>
            <div>
                <label for="map_offset_y">{{ _('Offset Y (px):') }}</label>
                <input type="number" id="map_offset_y" name="offset_y" value="0" style="width: 80px;">
            </div>
            <button type="submit">{{ _('Upload Map') }}</button>
        </form>
        <div id="upload-status"></div>
    </section>

    <hr>

    <section id="list-maps-section">
        <h2>{{ _('Existing Floor Maps') }}</h2>
        <button id="export-map-config-btn" class="button" style="margin-bottom: 10px;">{{ _('Export Map Configuration') }}</button>
        <input type="file" id="import-map-config-file" accept=".json" style="display: none; margin-left: 10px;">
        <button id="import-map-config-btn" class="button" style="margin-bottom: 10px; margin-left: 5px;">{{ _('Import Map Configuration') }}</button>
        <div id="admin-maps-list-status"></div>
        <div class="responsive-table-container">
        <table class="table" id="maps-table" style="width:100%;">
            <thead>
                <tr>
                    <th>{{ _('Name') }}</th>
                    <th>{{ _('Location') }}</th>
                    <th>{{ _('Floor') }}</th>
                    <th>{{ _('Image') }}</th>
                    <th>{{ _('Offset X (px)') }}</th>
                    <th>{{ _('Offset Y (px)') }}</th>
                    <th>{{ _('Actions') }}</th>
                </tr>
            </thead>
            <tbody id="maps-table-body">
                <tr><td colspan="7">{{ _('Loading maps...') }}</td></tr>
            </tbody>
        </table>
        </div>
        <!--
        Example row structure for JavaScript to populate into #maps-table-body:
        <tr data-map-id="MAP_ID_HERE">
            <td>MAP_NAME</td>
            <td>MAP_LOCATION</td>
            <td>MAP_FLOOR</td>
            <td><img src="MAP_IMAGE_URL" alt="MAP_NAME" style="width: 100px; height: auto;"></td>
            <td><input type="number" class="form-control map-offset-x-input" value="MAP_OFFSET_X" style="width: 70px;" aria-label="Offset X"></td>
            <td><input type="number" class="form-control map-offset-y-input" value="MAP_OFFSET_Y" style="width: 70px;" aria-label="Offset Y"></td>
            <td>
                <button class="button button-small update-map-offsets-btn" data-map-id="MAP_ID_HERE">Update Offsets</button>
                <button class="button button-small select-map-btn" data-map-id="MAP_ID_HERE" data-map-name="MAP_NAME" data-image-url="MAP_IMAGE_URL" data-offset-x="MAP_OFFSET_X" data-offset-y="MAP_OFFSET_Y">Define Areas</button>
                {# Removed "Manage Roles" button for the map itself #}
                <button class="button button-danger button-small delete-map-btn" data-map-id="MAP_ID_HERE">Delete</button>
            </td>
        </tr>
        -->
    </section>

    <hr>

    {# Removed Modal for Managing FloorMap Roles #}

    <section id="define-areas-section" style="display:none;">
        <h2>{{ _('Define Areas on Selected Map') }}</h2>
        <div id="define-areas-status"></div>
        <h3 id="selected-map-name"></h3>
        <div id="map-image-wrapper" style="position: relative; width: fit-content; height: fit-content; border: 1px solid #ccc; margin-bottom: 10px;">
            <img id="selected-map-image" src="#" alt="{{ _('Selected Map') }}" style="display: block; max-width: 800px; max-height: 600px;">
            <canvas id="drawing-canvas" style="position: absolute; top: 0; left: 0;"></canvas>
        </div>
        <form id="define-area-form">
            <h3>{{ _('Assign Area to Resource') }}</h3>
            <div>
                <label for="resource-to-map">{{ _('Select Resource:') }}</label>
                <select id="resource-to-map" name="resource_id" required>
                    <option value="--CREATE_NEW--">{{ _('-- Create New Resource --') }}</option>
                    <!-- Existing options will be populated by JS -->
                </select>
            </div>
            <div>
                <label for="booking-permission">{{ _('Booking Permission:') }}</label>
                <select id="booking-permission" name="booking_restriction">
                    <option value="">{{ _('Default (Requires Login, No Admin Restriction)') }}</option>
                    <option value="admin_only">{{ _('Admin Only') }}</option>
                </select>
            </div>
            <div>
                <label for="define-area-roles-select">{{ _('Restrict to Roles for this Area (Optional):') }}</label>
                <p class="small-text">{{ _('If roles are selected, only users with AT LEAST ONE of these roles will be able to book this resource when accessed via this specific map area. This is in addition to other resource-level permissions. Admins and users explicitly allowed on the resource can bypass this map area role check.') }}</p>
                <div id="define-area-roles-checkbox-container" class="checkbox-container" style="height: 100px; overflow-y: auto; border: 1px solid #ccc; padding: 5px;">
                    <small id="define-area-roles-loading-message">{{ _('Loading roles...') }}</small>
                    <!-- Checkboxes will be populated by JavaScript -->
                </div>
            </div>
            <div>
                <label>{{ _('Coordinates Type: Rectangle (fixed for now)') }}</label>
                <input type="hidden" id="coordinates-type" name="coordinates_type" value="rect">
            </div>
            <div>
                <label for="coord-x">{{ _('X:') }}</label>
                <input type="number" id="coord-x" name="x" required>
            </div>
            <div>
                <label for="coord-y">{{ _('Y:') }}</label>
                <input type="number" id="coord-y" name="y" required>
            </div>
            <div>
                <label for="coord-width">{{ _('Width:') }}</label>
                <input type="number" id="coord-width" name="width" required>
            </div>
            <div>
                <label for="coord-height">{{ _('Height:') }}</label>
                <input type="number" id="coord-height" name="height" required>
            </div>
            <input type="hidden" id="selected-floor-map-id" name="floor_map_id">
            <button type="submit">{{ _('Save Area for Resource') }}</button>
        </form>
        <div id="area-definition-status"></div>

        <div id="edit-delete-buttons" style="margin-top: 10px; display:none;">
            <button id="edit-selected-area-btn" class="button">{{ _('Edit Selected Area') }}</button>
            <button id="delete-selected-area-btn" class="button" style="background-color: #dc3545; color:white;">{{ _('Delete Selected Area Mapping') }}</button>
        </div>

        <div id="resource-actions-container" style="margin-top: 15px; padding: 10px; border: 1px dashed #ccc;">
            <p><em>{{ _('Select a resource from the dropdown above to see its status or publish actions.') }}</em></p>
            <button id="delete-resource-btn" class="button danger" style="display: none; margin-left: 10px;">{{ _('Delete Resource') }}</button>
        </div>
    </section>

    <div id="edit-resource-modal" class="modal" style="display: none;">
        <div class="modal-content">
            <span class="close-modal-btn" data-modal-id="edit-resource-modal">&times;</span>
            <h3>{{ _('Edit Resource Details') }}</h3>
            <form id="edit-resource-form">
                <input type="hidden" id="edit-resource-id" name="resource_id">
                <label for="edit-resource-name">{{ _('Name:') }}</label>
                <input type="text" id="edit-resource-name" name="name" required>
                <label for="edit-resource-capacity">{{ _('Capacity:') }}</label>
                <input type="number" id="edit-resource-capacity" name="capacity" min="0">
                <label for="edit-resource-equipment">{{ _('Equipment:') }}</label>
                <input type="text" id="edit-resource-equipment" name="equipment" placeholder="{{ _('e.g., Projector, Whiteboard') }}">
                <label for="edit-resource-image-file">{{ _('Image:') }}</label>
                <input type="file" id="edit-resource-image-file" name="resource_image" accept="image/png, image/jpeg">
                <img id="edit-resource-image-preview" src="#" alt="{{ _('Resource image preview') }}" style="max-width: 100%; display:none; margin-top:5px;">
                <label for="edit-resource-status">{{ _('Status:') }}</label>
                <select id="edit-resource-status" name="status">
                    <option value="draft">{{ _('Draft') }}</option>
                    <option value="published">{{ _('Published') }}</option>
                    <option value="archived">{{ _('Archived') }}</option>
                </select>
                <label for="edit-resource-booking-permission">{{ _('Booking Permission:') }}</label>
                <select id="edit-resource-booking-permission" name="booking_restriction">
                    <option value="">{{ _('Default (All Authenticated Users unless specified below)') }}</option>
                    <option value="admin_only">{{ _('Admin Only') }}</option>
                </select>
                <label for="edit-resource-maintenance">{{ _('Under Maintenance:') }}</label>
                <input type="checkbox" id="edit-resource-maintenance" name="is_under_maintenance">
                <label for="edit-resource-maintenance-until">{{ _('Maintenance Until:') }}</label>
                <input type="datetime-local" id="edit-resource-maintenance-until" name="maintenance_until">
                <label for="edit-resource-recurrence-limit">{{ _('Max Recurrence Count:') }}</label>
                <input type="number" id="edit-resource-recurrence-limit" name="max_recurrence_count" min="1">

                <div>
                    <label for="edit-resource-scheduled-status">{{ _('Scheduled Status Change To:') }}</label>
                    <select id="edit-resource-scheduled-status" name="scheduled_status">
                        <option value="">{{ _('-- No Scheduled Change --') }}</option>
                        <option value="draft">{{ _('Draft') }}</option>
                        <option value="published">{{ _('Published') }}</option>
                        <option value="archived">{{ _('Archived') }}</option>
                    </select>
                </div>
                <div>
                    <label for="edit-resource-scheduled-at">{{ _('Scheduled Change At:') }}</label>
                    <input type="datetime-local" id="edit-resource-scheduled-at" name="scheduled_status_at">
                </div>

                <div class="permission-group">
                    <h4>{{ _('Authorized Specific Users (Optional)') }}</h4>
                    <p class="small-text">{{ _('If specified, only these users (and admins) can book.') }}</p>
                    <div id="edit-authorized-users-checkbox-container" class="checkbox-container" style="height: 100px; overflow-y: auto; border: 1px solid #ccc; padding: 5px;">
                    </div>
                </div>
                <div class="permission-group">
                    <label>{{ _('Authorized Roles (Optional):') }}</label>
                    <p class="small-text">{{ _('If specified, only users with these roles can book. This complements user-specific permissions.') }}</p>
                    <div id="edit-resource-authorized-roles-checkbox-container" class="checkbox-container" style="height: 100px; overflow-y: auto; border: 1px solid #ccc; padding: 5px;">
                        <small>{{ _('Loading roles...') }}</small>
                    </div>
                </div>
                <button type="submit" class="button">{{ _('Save Changes') }}</button>
                <div id="edit-resource-status-message" class="status-message" style="margin-top: 10px;"></div>
            </form>
        </div>
    </div>
{% endblock %}

{% block scripts %}
    {{ super() }}
    <script src="{{ url_for('static', filename='js/admin_resource_edit.js') }}" defer></script>
    <script src="{{ url_for('static', filename='js/admin_resource_roles.js') }}" defer></script>
    <script>
    document.addEventListener('DOMContentLoaded', function() {
        const mapsTableBody = document.getElementById('maps-table-body');
        const adminMapsListStatus = document.getElementById('admin-maps-list-status');
        const csrfTokenMeta = document.querySelector('meta[name="csrf-token"]'); // CSRF token for AJAX

        // Function to display status messages
        function showStatus(element, message, isError = false) {
            if (element) {
                element.textContent = message;
                element.className = 'status-message ' + (isError ? 'error' : 'success');
                if (message) {
                    element.style.display = 'block'; // Show the message element
                } else {
                    element.style.display = 'none'; // Hide if no message
                }
            }
        }

        // Function to render maps in the table
        function renderMaps(maps) {
            mapsTableBody.innerHTML = ''; // Clear existing rows (e.g., "Loading maps...")
            if (!maps || maps.length === 0) {
                mapsTableBody.innerHTML = '<tr><td colspan="7">{{ _("No maps found.") }}</td></tr>';
                return;
            }

            maps.forEach(map => {
                const row = mapsTableBody.insertRow();
                row.dataset.mapId = map.id;

                row.insertCell().textContent = map.name || 'N/A';
                row.insertCell().textContent = map.location || 'N/A';
                row.insertCell().textContent = map.floor || 'N/A';

                const imgCell = row.insertCell();
                if (map.image_url) {
                    const img = document.createElement('img');
                    img.src = map.image_url;
                    img.alt = map.name || 'Map Image';
                    img.style.width = '100px';
                    img.style.height = 'auto';
                    imgCell.appendChild(img);
                } else {
                    imgCell.textContent = 'No image';
                }

                const offsetXCell = row.insertCell();
                const offsetXInput = document.createElement('input');
                offsetXInput.type = 'number';
                offsetXInput.className = 'form-control map-offset-x-input'; // Ensure 'form-control' styles apply if desired
                offsetXInput.value = map.offset_x !== undefined ? map.offset_x : 0;
                offsetXInput.style.width = '70px';
                offsetXInput.setAttribute('aria-label', 'Offset X');
                offsetXCell.appendChild(offsetXInput);

                const offsetYCell = row.insertCell();
                const offsetYInput = document.createElement('input');
                offsetYInput.type = 'number';
                offsetYInput.className = 'form-control map-offset-y-input';
                offsetYInput.value = map.offset_y !== undefined ? map.offset_y : 0;
                offsetYInput.style.width = '70px';
                offsetYInput.setAttribute('aria-label', 'Offset Y');
                offsetYCell.appendChild(offsetYInput);

                const actionsCell = row.insertCell();
                const updateButton = document.createElement('button');
                updateButton.className = 'button button-small update-map-offsets-btn';
                updateButton.dataset.mapId = map.id;
                updateButton.textContent = '{{ _("Update Offsets") }}';
                actionsCell.appendChild(updateButton);

                // Add Define Areas button (from example structure)
                const defineAreasButton = document.createElement('button');
                defineAreasButton.className = 'button button-small select-map-btn';
                defineAreasButton.dataset.mapId = map.id;
                defineAreasButton.dataset.mapName = map.name;
                defineAreasButton.dataset.imageUrl = map.image_url;
                defineAreasButton.dataset.offsetX = map.offset_x; // Pass offsets to define areas
                defineAreasButton.dataset.offsetY = map.offset_y;
                defineAreasButton.textContent = '{{ _("Define Areas") }}';
                defineAreasButton.style.marginLeft = '5px';
                actionsCell.appendChild(defineAreasButton);

                {# Removed "Manage Roles" button from here #}

                // Add Delete button (from example structure)
                const deleteButton = document.createElement('button');
                deleteButton.className = 'button button-danger button-small delete-map-btn';
                deleteButton.dataset.mapId = map.id;
                deleteButton.textContent = '{{ _("Delete") }}';
                deleteButton.style.marginLeft = '5px';
                actionsCell.appendChild(deleteButton);
            });
        }

        // Function to fetch maps
        async function loadMaps() {
            showStatus(adminMapsListStatus, '{{ _("Loading maps...") }}', false);
            try {
                const response = await fetch('/api/admin/maps'); // This API now returns 'assigned_role_ids'
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const maps = await response.json();
                renderMaps(maps); // maps should contain 'assigned_role_ids' for each map
                showStatus(adminMapsListStatus, '{{ _("Maps loaded.") }}', false);
                setTimeout(() => { if(adminMapsListStatus && adminMapsListStatus.textContent === '{{ _("Maps loaded.") }}') showStatus(adminMapsListStatus, '', false); }, 3000);
            } catch (error) {
                console.error('Error loading maps:', error);
                showStatus(adminMapsListStatus, '{{ _("Error loading maps.") }}', true);
                mapsTableBody.innerHTML = `<tr><td colspan="7">{{ _("Error loading maps.") }}</td></tr>`;
            }
        }

        // --- Removed Map Roles Modal Logic ---
        let allRolesForAreaAssignment = []; // Store roles for area assignment

        async function loadAllRolesForAreaDefinition() {
            // Removed: if (allRolesForAreaAssignment.length > 0) return; // Let it re-fetch if needed, or rely on populate to show status
            const rolesLoadingMsg = document.getElementById('define-area-roles-loading-message');
            if (rolesLoadingMsg) { // Show loading message initially
                rolesLoadingMsg.textContent = '{{ _("Loading roles...") }}';
                rolesLoadingMsg.style.display = 'block';
            }

            try {
                const response = await fetch('/api/admin/roles');
                if (!response.ok) {
                    // This error will be caught by the catch block below
                    throw new Error(`HTTP error! status: ${response.status}, message: ${response.statusText}`);
                }
                const data = await response.json(); // Assuming data is the array of roles or an object like {roles: []}
                // Standardize to ensure allRolesForAreaAssignment is always an array
                if (Array.isArray(data)) {
                    allRolesForAreaAssignment = data;
                } else if (data && Array.isArray(data.roles)) { // Handle if API returns {roles: [...]}
                    allRolesForAreaAssignment = data.roles;
                } else {
                     allRolesForAreaAssignment = []; // Default to empty if structure is unexpected
                }

                if (allRolesForAreaAssignment.length === 0) {
                    // This case (successful fetch, but no roles) will be handled by populateDefineAreaRolesSelect
                }
                // populateDefineAreaRolesSelect will hide the loading message if roles are found
            } catch (error) {
                console.error('Error fetching all roles for area assignment:', error);
                allRolesForAreaAssignment = []; // Reset on error
                if (rolesLoadingMsg) {
                    rolesLoadingMsg.textContent = '{{ _("Error loading roles. Please try again or contact support.") }}';
                    rolesLoadingMsg.style.display = 'block';
                }
            }
            populateDefineAreaRolesCheckboxes(); // Populate/update messages after fetch attempt
        }

        function populateDefineAreaRolesCheckboxes(selectedRoleIds = []) {
            const numericSelectedRoleIds = (selectedRoleIds || []).map(id => parseInt(id, 10)).filter(id => !isNaN(id));
            const checkboxContainer = document.getElementById('define-area-roles-checkbox-container');
            const rolesLoadingMsg = document.getElementById('define-area-roles-loading-message');
            if (!checkboxContainer) return;

            // Clear previous content except the loading message itself
            checkboxContainer.innerHTML = '';
            checkboxContainer.appendChild(rolesLoadingMsg); // Re-append loading message so it's not lost

            if (rolesLoadingMsg) {
                rolesLoadingMsg.style.display = 'none'; // Hide by default, show if needed
            }

            if (!allRolesForAreaAssignment || allRolesForAreaAssignment.length === 0) {
                if (rolesLoadingMsg) {
                    const currentText = rolesLoadingMsg.textContent || "";
                    if (currentText.includes("{{ _("Error loading roles") }}")) {
                         rolesLoadingMsg.style.display = 'block';
                    } else {
                        rolesLoadingMsg.textContent = '{{ _("No roles available to assign. Please create roles in user management first.") }}';
                        rolesLoadingMsg.style.display = 'block';
                    }
                }
                return;
            }

            // If we have roles, ensure the loading/error message is hidden
            if (rolesLoadingMsg) {
                 rolesLoadingMsg.style.display = 'none';
            }

            allRolesForAreaAssignment.forEach(role => {
                const div = document.createElement('div');
                div.className = 'checkbox-item'; // For styling if needed

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `area-role-checkbox-${role.id}`;
                checkbox.value = role.id;
                checkbox.name = 'area_roles'; // Consistent name for grouping

                if (numericSelectedRoleIds.includes(role.id)) {
                    checkbox.checked = true;
                }

                const label = document.createElement('label');
                label.htmlFor = checkbox.id;
                label.textContent = role.name + (role.description ? ` (${role.description})` : '');

                div.appendChild(checkbox);
                div.appendChild(label);
                checkboxContainer.appendChild(div);
            });
        }

        // Event listener for map actions (using event delegation on mapsTableBody)
        mapsTableBody.addEventListener('click', async function(event) {
            const targetButton = event.target.closest('button'); // Get the button element if a child was clicked
            if (!targetButton) return;

            if (targetButton.classList.contains('update-map-offsets-btn')) {
                const mapId = targetButton.dataset.mapId;
                const row = targetButton.closest('tr'); // Corrected to use targetButton.closest
                const offsetXInput = row.querySelector('.map-offset-x-input');
                const offsetYInput = row.querySelector('.map-offset-y-input');

                const offsetX = parseInt(offsetXInput.value);
                const offsetY = parseInt(offsetYInput.value);

                if (isNaN(offsetX) || isNaN(offsetY)) {
                    showStatus(adminMapsListStatus, '{{ _("Invalid offset value. Please enter numbers.") }}', true);
                    return;
                }

                showStatus(adminMapsListStatus, `{{ _("Updating offsets for map ID ${mapId}...") }}`, false);
                try {
                    const currentCsrfToken = csrfTokenMeta ? csrfTokenMeta.getAttribute('content') : document.querySelector('input[name="csrf_token"]')?.value;
                    if (!currentCsrfToken) {
                        showStatus(adminMapsListStatus, '{{ _("CSRF token not found. Cannot update.") }}', true);
                        console.error('CSRF token not found for offset update.');
                        return;
                    }

                    const response = await fetch(`/api/admin/maps/${mapId}/offsets`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': currentCsrfToken
                        },
                        body: JSON.stringify({ offset_x: offsetX, offset_y: offsetY })
                    });
                    const result = await response.json();
                    if (!response.ok) {
                        throw new Error(result.error || `HTTP error! status: ${response.status}`);
                    }
                    showStatus(adminMapsListStatus, result.message || '{{ _("Offsets updated successfully.") }}', false);
                    if(result.map) {
                        offsetXInput.value = result.map.offset_x;
                        offsetYInput.value = result.map.offset_y;
                        const defineAreasBtn = row.querySelector('.select-map-btn');
                        if(defineAreasBtn) {
                            defineAreasBtn.dataset.offsetX = result.map.offset_x;
                            defineAreasBtn.dataset.offsetY = result.map.offset_y;
                        }
                    }
                } catch (error) {
                    console.error('Error updating map offsets:', error);
                    showStatus(adminMapsListStatus, `{{ _("Error updating offsets: ${error.message}") }}`, true);
                }
            } // End of update-map-offsets-btn logic

            {# Removed manage-map-roles-btn handling #}

            else if (targetButton.classList.contains('select-map-btn')) {
                const mapId = targetButton.dataset.mapId;
                const mapName = targetButton.dataset.mapName;
                const imageUrl = targetButton.dataset.imageUrl;
                const offsetX = parseInt(targetButton.dataset.offsetX || '0');
                const offsetY = parseInt(targetButton.dataset.offsetY || '0');

                console.log(`Define Areas clicked for map ID: ${mapId}, Name: ${mapName}, Image: ${imageUrl}, OffsetX: ${offsetX}, OffsetY: ${offsetY}`);

                const defineAreasSection = document.getElementById('define-areas-section');
                if (defineAreasSection) defineAreasSection.style.display = 'block';

                const selectedMapNameEl = document.getElementById('selected-map-name');
                if (selectedMapNameEl) selectedMapNameEl.textContent = mapName || 'N/A';

                const selectedMapImageEl = document.getElementById('selected-map-image');
                if (selectedMapImageEl) {
                    selectedMapImageEl.src = imageUrl || '#';
                    selectedMapImageEl.alt = mapName || 'Selected Map';
                }

                const selectedFloorMapIdInput = document.getElementById('selected-floor-map-id');
                if (selectedFloorMapIdInput) selectedFloorMapIdInput.value = mapId;

                window.currentMapContext = { mapId, mapName, imageUrl, offsetX, offsetY };

                // Populate resources dropdown (can happen before image load)
                if (typeof window.populateResourcesForMapping === 'function') {
                    window.populateResourcesForMapping(mapId);
                } else {
                    console.warn('populateResourcesForMapping function not found.');
                }

                // Ensure canvas logic runs after image is loaded
                const selectedMapImageElForLoad = document.getElementById('selected-map-image'); // Re-fetch to be sure
                if (selectedMapImageElForLoad) { // Check if element exists
                    selectedMapImageElForLoad.onload = function() {
                        console.log("Map image loaded. Initializing canvas and drawing areas.");
                        if (typeof window.initializeDefineAreasCanvasLogic === 'function') {
                            window.initializeDefineAreasCanvasLogic();
                        } else {
                            console.warn('initializeDefineAreasCanvasLogic function not found.');
                        }
                        if (typeof window.fetchAndDrawExistingMapAreas === 'function') {
                            window.fetchAndDrawExistingMapAreas(mapId);
                        } else {
                            console.warn('fetchAndDrawExistingMapAreas function not found.');
                        }
                    };
                    // If the image is already loaded from cache, 'onload' might not fire.
                    // Trigger it manually if complete and naturalWidth > 0.
                    if (selectedMapImageElForLoad.complete && selectedMapImageElForLoad.naturalWidth && selectedMapImageElForLoad.naturalWidth > 0) {
                        console.log("Map image already complete, manually triggering onload logic.");
                        selectedMapImageElForLoad.onload(); // Call the handler directly
                    } else if (!selectedMapImageElForLoad.src || selectedMapImageElForLoad.src === window.location.href + "#") { // If src is empty or just '#'
                        console.log("Map image src is empty or '#', not attempting to trigger onload.");
                    }
                } else {
                    console.error("selected-map-image element not found for onload binding.");
                }

                if(defineAreasSection) defineAreasSection.scrollIntoView({ behavior: 'smooth' });

                // Ensure roles are loaded when map is selected for area definition
                loadAllRolesForAreaDefinition();
                populateDefineAreaRolesCheckboxes(); // Clear and populate, any selected roles will be set by populateAreaForm if an area is later selected for edit
            } // End of select-map-btn logic

            else if (targetButton.classList.contains('delete-map-btn')) {
                const mapId = targetButton.dataset.mapId;
                const mapRow = targetButton.closest('tr');
                const mapName = mapRow ? (mapRow.cells[0] ? mapRow.cells[0].textContent : `Map ID ${mapId}`) : `Map ID ${mapId}`;

                if (!confirm(`{{ _("Are you sure you want to delete map '${mapName}' (ID: ${mapId})? This will also remove any associated resource area mappings.") }}`)) {
                    return;
                }

                showStatus(adminMapsListStatus, `{{ _("Deleting map ${mapName}...") }}`, false);
                const currentCsrfToken = csrfTokenMeta ? csrfTokenMeta.getAttribute('content') : document.querySelector('input[name="csrf_token"]')?.value;
                if (!currentCsrfToken) {
                    showStatus(adminMapsListStatus, '{{ _("CSRF token not found. Cannot delete.") }}', true);
                    console.error('CSRF token not found for delete operation.');
                    return;
                }

                try {
                    const response = await fetch(`/api/admin/maps/${mapId}`, {
                        method: 'DELETE',
                        headers: {
                            'X-CSRFToken': currentCsrfToken
                        }
                    });
                    const result = await response.json();
                    if (!response.ok) {
                        const errorDetail = result && result.error ? result.error : response.statusText;
                        throw new Error(errorDetail || `HTTP error! status: ${response.status}`);
                    }
                    showStatus(adminMapsListStatus, result.message || `{{ _("Map '${mapName}' deleted successfully.") }}`, false);
                    if (mapRow) mapRow.remove();

                    const defineAreasSection = document.getElementById('define-areas-section');
                    const selectedFloorMapIdInput = document.getElementById('selected-floor-map-id');
                    if (defineAreasSection && selectedFloorMapIdInput && selectedFloorMapIdInput.value === mapId) {
                        defineAreasSection.style.display = 'none';
                        selectedFloorMapIdInput.value = '';
                        document.getElementById('selected-map-name').textContent = '';
                        document.getElementById('selected-map-image').src = '#';
                        const canvas = document.getElementById('drawing-canvas');
                        if (canvas) {
                            const context = canvas.getContext('2d');
                            context.clearRect(0, 0, canvas.width, canvas.height);
                        }
                    }
                } catch (error) {
                    console.error('Error deleting map:', error);
                    showStatus(adminMapsListStatus, `{{ _("Error deleting map '${mapName}': ${error.message}") }}`, true);
                }
            } // End of delete-map-btn logic
        });

        // Initial load of maps
        loadMaps();

        // Handle map upload form
        const uploadMapForm = document.getElementById('upload-map-form');
        const uploadStatusDiv = document.getElementById('upload-status');
        if (uploadMapForm) {
            uploadMapForm.addEventListener('submit', async function(event) {
                event.preventDefault();
                event.stopImmediatePropagation(); // Prevent other listeners on this form

                showStatus(uploadStatusDiv, '{{ _("Uploading map...") }}');
                const formData = new FormData(uploadMapForm);
                // CSRF token is included as a hidden field in formData: <input type="hidden" name="csrf_token" value="{{ csrf_token() }}">
                try {
                    const response = await fetch('/api/admin/maps', {
                        method: 'POST',
                        body: formData
                        // No 'X-CSRFToken' header needed for FormData when using Flask-WTF's hidden field.
                        // No 'Content-Type' header needed, browser sets it for FormData.
                    });
                    const result = await response.json();
                    if (!response.ok) {
                        throw new Error(result.error || `HTTP error! status: ${response.status}`);
                    }
                    showStatus(uploadStatusDiv, result.message || '{{ _("Map uploaded successfully!") }}', false);
                    uploadMapForm.reset();
                    loadMaps(); // Refresh the list of maps
                } catch (error) {
                    console.error('Error uploading map:', error);
                    showStatus(uploadStatusDiv, `{{ _("Error uploading map: ${error.message}") }}`, true);
                }
            });
        }

                // Initial load of maps
        loadMaps();
        // Roles for area definition will be loaded when "Define Areas" is shown or area selected.

        // --- START: Canvas Drawing and Area Selection Logic ---
        let canvas, ctx, selectedMapImageForCanvas;
        let isDrawing = false;
        let startX, startY, currentX, currentY;
        let drawnAreas = []; // To store areas fetched from backend and newly drawn ones
        let selectedArea = null; // To store the currently selected area object
        const defineAreasStatus = document.getElementById('define-areas-status'); // For messages

        window.initializeDefineAreasCanvasLogic = function() {
            canvas = document.getElementById('drawing-canvas');
            selectedMapImageForCanvas = document.getElementById('selected-map-image');
            const editDeleteButtons = document.getElementById('edit-delete-buttons');

            if (!canvas || !selectedMapImageForCanvas) {
                console.error('Canvas or map image element not found for initialization.');
                showStatus(defineAreasStatus, {{ _("Error initializing area definition tool: Canvas or image missing.")|tojson }}, true);
                return;
            }
            ctx = canvas.getContext('2d');

            // Set canvas dimensions to match the image
            canvas.width = selectedMapImageForCanvas.clientWidth;
            canvas.height = selectedMapImageForCanvas.clientHeight;
            console.log(`Canvas initialized with dimensions: ${canvas.width}x${canvas.height}`);

            // Event Listeners for drawing
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUpOrLeave);
            canvas.addEventListener('mouseleave', handleMouseUpOrLeave); // Stop drawing if mouse leaves canvas
            canvas.addEventListener('click', handleCanvasClick);

            // Clear form and hide edit/delete buttons initially
            resetAreaSelectionAndForm();
        }

        function handleMouseDown(event) {
            if (!window.currentMapContext) return; // No map selected
            // Clear previous selection and reset form before drawing a new area
            if (selectedArea) {
                selectedArea = null; // Deselect
                resetAreaSelectionAndForm(); // Clear form and hide buttons
            }

            isDrawing = true;
            const rect = canvas.getBoundingClientRect();
            startX = event.clientX - rect.left;
            startY = event.clientY - rect.top;
            currentX = startX;
            currentY = startY;
            console.log(`Mouse down at (${startX}, ${startY})`);
        }

        function handleMouseMove(event) {
            if (!isDrawing || !window.currentMapContext) return;
            const rect = canvas.getBoundingClientRect();
            currentX = event.clientX - rect.left;
            currentY = event.clientY - rect.top;
            redrawCanvas(); // Redraw all areas and the current drawing rectangle
        }

        function handleMouseUpOrLeave(event) {
            if (!isDrawing || !window.currentMapContext) return;
            isDrawing = false;
            const width = currentX - startX;
            const height = currentY - startY;

            console.log(`Mouse up/leave. Drawn rect: x=${startX}, y=${startY}, w=${width}, h=${height}`);

            if (Math.abs(width) > 5 && Math.abs(height) > 5) { // Minimum size for a new area
                const newArea = {
                    x: Math.min(startX, currentX),
                    y: Math.min(startY, currentY),
                    width: Math.abs(width),
                    height: Math.abs(height),
                    resource_id: null, // New area, not yet associated
                    allowed_role_ids: [] // Default empty
                };
                // Don't add to drawnAreas yet, let selection populate the form
                // This new rect is implicitly the "selected" one for the form
                populateAreaFormWithCoords(newArea);
                showStatus(defineAreasStatus, {{ _("New area drawn. Fill details and save.")|tojson }}, false);
                // Do not show edit/delete for a brand new, unsaved area
                document.getElementById('edit-delete-buttons').style.display = 'none';
                selectedArea = newArea; // Treat new drawing as selected for redraw purposes
            } else {
                showStatus(defineAreasStatus, {{ _("Area too small to define.")|tojson }}, true);
            }
            redrawCanvas(); // Redraw to show the final new area (or clear if too small)
        }

        function handleCanvasClick(event) {
            if (isDrawing || !window.currentMapContext) return; // Don't select if currently drawing
            const rect = canvas.getBoundingClientRect();
            const clickX = event.clientX - rect.left;
            const clickY = event.clientY - rect.top;

            let clickedOnArea = null;
            // Check from top-most (last drawn) to bottom
            for (let i = drawnAreas.length - 1; i >= 0; i--) {
                const area = drawnAreas[i];
                if (clickX >= area.x && clickX <= area.x + area.width &&
                    clickY >= area.y && clickY <= area.y + area.height) {
                    clickedOnArea = area;
                    break;
                }
            }

            if (clickedOnArea) {
                selectedArea = clickedOnArea;
                console.log("Selected existing area:", selectedArea);
                populateAreaFormWithCoords(selectedArea.coordinates, selectedArea.resource_id, selectedArea.booking_restriction, selectedArea.allowed_role_ids);
                document.getElementById('edit-delete-buttons').style.display = 'block';
                showStatus(defineAreasStatus, `Selected area for resource ID: ${selectedArea.resource_id || 'Unassigned'}.`, false);
            } else {
                // Clicked outside any area, deselect if one was selected
                if (selectedArea) {
                    selectedArea = null;
                    resetAreaSelectionAndForm();
                    showStatus(defineAreasStatus, {{ _("Canvas clicked, no area selected. Draw a new area or click an existing one.")|tojson }}, false);
                }
            }
            redrawCanvas();
        }

        function populateAreaFormWithCoords(coordinates, resourceId = null, bookingRestriction = '', allowedRoleIds = []) {
            document.getElementById('coord-x').value = coordinates.x || 0;
            document.getElementById('coord-y').value = coordinates.y || 0;
            document.getElementById('coord-width').value = coordinates.width || 0;
            document.getElementById('coord-height').value = coordinates.height || 0;

            const resourceSelect = document.getElementById('resource-to-map');
            if (resourceId) {
                resourceSelect.value = resourceId;
            } else {
                // For a new drawing, or if area is not tied to a specific resource yet in data
                resourceSelect.value = '--CREATE_NEW--'; // Or keep it blank, depending on desired UX
            }
            // Trigger change to update dependent UI if any (e.g. resource actions)
            resourceSelect.dispatchEvent(new Event('change'));


            document.getElementById('booking-permission').value = bookingRestriction || '';
            populateDefineAreaRolesCheckboxes(allowedRoleIds || []);

            // If global populateAreaForm exists and does more, call it
            // This is now the primary populator for coords and roles.
            // window.populateAreaForm might be designed to expect a full area object.
        }

        function resetAreaSelectionAndForm() {
            document.getElementById('define-area-form').reset();
            populateDefineAreaRolesCheckboxes([]); // Clear role checkboxes
            selectedArea = null;
            document.getElementById('edit-delete-buttons').style.display = 'none';
            const resourceSelect = document.getElementById('resource-to-map');
            resourceSelect.value = '--CREATE_NEW--';
            resourceSelect.dispatchEvent(new Event('change')); // Update dependent UI
            // redrawCanvas(); // Call if needed, but usually after an action
        }


        window.fetchAndDrawExistingMapAreas = async function(mapId) {
            if (!mapId) {
                console.warn("fetchAndDrawExistingMapAreas called with no mapId");
                drawnAreas = [];
                redrawCanvas();
                return;
            }
            const fetchMsgBase = {{ _("Fetching areas for map ID: %s")|tojson }};
            const fetchMsg = fetchMsgBase.replace('%s', mapId);
            showStatus(defineAreasStatus, fetchMsg, false);
            try {
                // This API endpoint needs to return resources that have map_coordinates for this mapId
                const response = await fetch(`/api/admin/resources?map_id=${mapId}`);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const resources = await response.json();

                drawnAreas = resources.filter(r => r.map_coordinates && r.floor_map_id == mapId)
                                     .map(r => ({ // Adapt to the expected structure for drawing
                                         resource_id: r.id,
                                         name: r.name, // For potential display on canvas later
                                         coordinates: r.map_coordinates, // Assumes map_coordinates is {x, y, width, height, type}
                                         booking_restriction: r.booking_restriction,
                                         allowed_role_ids: r.map_coordinates.allowed_role_ids || []
                                     }));

                console.log("Fetched and processed areas: ", drawnAreas);
                const foundAreasMsgBase = {{ _("Found %s areas.")|tojson }};
                const foundAreasMsg = foundAreasMsgBase.replace('%s', drawnAreas.length);
                showStatus(defineAreasStatus, foundAreasMsg, false);
            } catch (error) {
                console.error('Error fetching or processing map areas:', error);
                const errorMsgBase = {{ _("Error fetching areas: %s")|tojson }};
                const errorMsg = errorMsgBase.replace('%s', error.message);
                showStatus(defineAreasStatus, errorMsg, true);
                drawnAreas = [];
            }
            redrawCanvas();
        }

        function redrawCanvas() {
            if (!ctx || !canvas) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw all existing/saved areas
            drawnAreas.forEach(area => {
                if (area.coordinates) { // Ensure coordinates exist
                    drawRectangle(area.coordinates, selectedArea === area, false);
                }
            });

            // If currently drawing a new rectangle, draw it too
            if (isDrawing) {
                const tempRect = {
                    x: Math.min(startX, currentX),
                    y: Math.min(startY, currentY),
                    width: Math.abs(currentX - startX),
                    height: Math.abs(currentY - startY)
                };
                drawRectangle(tempRect, true, true); // Highlight as "selected" and "new"
            } else if (selectedArea && !drawnAreas.includes(selectedArea) && selectedArea.width && selectedArea.height) {
                // This handles showing a newly drawn (but not yet saved) rectangle as selected
                 drawRectangle(selectedArea, true, false);
            }
        }

        function drawRectangle(rectCoords, isCurrentlySelected = false, isNewDrawing = false) {
            if (!rectCoords) return;

            let x = rectCoords.x;
            let y = rectCoords.y;
            let width = rectCoords.width;
            let height = rectCoords.height;

            // Adjust for map offsets if they are part of window.currentMapContext
            // The canvas coordinates should be absolute to the image, so offsets are usually applied when calculating
            // the coordinates to store, not during drawing. However, if coordinates are stored *without* offset
            // and offset is applied at display time, this is where it would happen.
            // Assuming coordinates are already offset-adjusted as per current setup.

            ctx.beginPath();
            ctx.rect(x, y, width, height);

            if (isCurrentlySelected) {
                ctx.fillStyle = 'rgba(0, 255, 0, 0.3)'; // Light green for selected
                ctx.strokeStyle = 'rgba(0, 255, 0, 0.8)';
                ctx.lineWidth = 2;
            } else if (isNewDrawing) {
                ctx.fillStyle = 'rgba(0, 0, 255, 0.2)'; // Light blue for new drawing
                ctx.strokeStyle = 'rgba(0, 0, 255, 0.7)';
                ctx.lineWidth = 1;
            }
            else {
                ctx.fillStyle = 'rgba(255, 165, 0, 0.3)'; // Light orange for existing
                ctx.strokeStyle = 'rgba(255, 165, 0, 0.8)';
                ctx.lineWidth = 1;
            }
            ctx.fill();
            ctx.stroke();
            ctx.closePath();
        }

        // Edit and Delete button listeners
        const editAreaBtn = document.getElementById('edit-selected-area-btn');
        const deleteAreaBtn = document.getElementById('delete-selected-area-btn');

        if (editAreaBtn) {
            editAreaBtn.addEventListener('click', function() {
                if (!selectedArea || !selectedArea.resource_id) { // Can only edit saved areas
                    showStatus(defineAreasStatus, {{ _("No saved area selected to edit.")|tojson }}, true);
                    return;
                }
                // For "edit", we can simply allow the user to re-draw.
                // Clear the selected area, keep form populated, user can draw new rect.
                // The current selectedArea's data (resource_id etc.) will be used on save.
                showStatus(defineAreasStatus, {{ _("Edit mode: Draw a new rectangle for the selected resource. The existing area will be replaced upon saving.")|tojson }}, false);
                // Effectively, we are just keeping the form data and allowing a new shape to be drawn.
                // The save operation will then update the coordinates for selectedArea.resource_id.
                // No specific drawing state change, user just draws again. The form holds the context.
                // selectedArea = null; // Deselect to remove highlight, but form keeps data
                // redrawCanvas();
                // Better UX: Keep it selected, but indicate that drawing again will modify it.
                // For now, let's just rely on the message and the next save action.
                 alert({{ _('To edit, adjust values in the form or re-draw the rectangle on the canvas. Then click Save Area.')|tojson }});
            });
        }

        if (deleteAreaBtn) {
            deleteAreaBtn.addEventListener('click', async function() {
                if (!selectedArea || !selectedArea.resource_id) {
                    showStatus(defineAreasStatus, {{ _("No saved area selected to delete.")|tojson }}, true);
                    return;
                }
                const confirmMsgBase = {{ _("Are you sure you want to remove the area mapping for resource '%s'? The resource itself will not be deleted.")|tojson }};
                const resourceNameOrId = selectedArea.name || selectedArea.resource_id || 'Unnamed Resource';
                const confirmMsg = confirmMsgBase.replace('%s', resourceNameOrId);
                if (!confirm(confirmMsg)) {
                    return;
                }

                const deleteProgressMsgBase = {{ _("Deleting area for resource %s...")|tojson }};
                const deleteProgressMsg = deleteProgressMsgBase.replace('%s', selectedArea.resource_id);
                showStatus(defineAreasStatus, deleteProgressMsg, false);
                const csrfToken = csrfTokenMeta ? csrfTokenMeta.getAttribute('content') : document.querySelector('input[name="csrf_token"]')?.value;
                try {
                    // To delete an area, we update the resource to have null map_coordinates
                    const response = await fetch(`/api/admin/resources/${selectedArea.resource_id}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': csrfToken
                        },
                        body: JSON.stringify({
                            floor_map_id: null, // Or currentMapContext.mapId with null coordinates
                            map_coordinates: null,
                            // Retain other properties of the resource by not sending them or sending original values
                        })
                    });
                    const result = await response.json();
                    if (!response.ok) {
                        throw new Error(result.error || `HTTP error! status: ${response.status}`);
                    }
                    showStatus(defineAreasStatus, result.message || {{ _("Area mapping deleted successfully.")|tojson }}, false);

                    // Refresh areas from backend
                    if (window.currentMapContext) {
                        fetchAndDrawExistingMapAreas(window.currentMapContext.mapId);
                    }
                    resetAreaSelectionAndForm();

                } catch (error) {
                    console.error('Error deleting area mapping:', error);
                    const deleteErrorMsgBase = {{ _("Error deleting area: %s")|tojson }};
                    const deleteErrorMsg = deleteErrorMsgBase.replace('%s', error.message);
                    showStatus(defineAreasStatus, deleteErrorMsg, true);
                }
            });
        }

        // --- END: Canvas Drawing and Area Selection Logic ---

        // --- Define Area Form Logic (Moved into DOMContentLoaded) ---
        const defineAreaForm = document.getElementById('define-area-form');
        if (defineAreaForm) {
            defineAreaForm.addEventListener('submit', async function(event) {
                event.preventDefault();
                const formData = new FormData(defineAreaForm);
                const resourceId = formData.get('resource_id'); // This might be --CREATE_NEW--
                const floorMapId = document.getElementById('selected-floor-map-id').value;
                const areaStatusDiv = document.getElementById('area-definition-status');

                const selectedAreaRoleIds = [];
                document.querySelectorAll('#define-area-roles-checkbox-container input[type="checkbox"]:checked').forEach(checkbox => {
                    selectedAreaRoleIds.push(parseInt(checkbox.value));
                });

                const areaData = {
                    floor_map_id: floorMapId,
                    coordinates: {
                        type: formData.get('coordinates_type'),
                        x: parseInt(formData.get('x')),
                        y: parseInt(formData.get('y')),
                        width: parseInt(formData.get('width')),
                        height: parseInt(formData.get('height')),
                        allowed_role_ids: selectedAreaRoleIds
                    },
                    booking_restriction: formData.get('booking_restriction'),
                    name: resourceId === '--CREATE_NEW--' ? 'New Resource from Map Area' : undefined,
                    status: resourceId === '--CREATE_NEW--' ? 'draft' : undefined
                };

                Object.keys(areaData).forEach(key => areaData[key] === undefined && delete areaData[key]);
                if (areaData.coordinates) {
                     Object.keys(areaData.coordinates).forEach(key => areaData.coordinates[key] === undefined && delete areaData.coordinates[key]);
                }

                let targetResourceId = resourceId;
                if (resourceId === '--CREATE_NEW--') {
                    showStatus(areaStatusDiv, {{ _("Resource creation from this form is complex. Please map to existing resources for now.")|tojson }}, true);
                    console.error("Resource creation from define-area-form is not fully implemented in this example script block.");
                    return;
                }

                if (!targetResourceId || targetResourceId === '--CREATE_NEW--') {
                     showStatus(areaStatusDiv, {{ _("Please select a valid resource to map.")|tojson }}, true);
                     return;
                }

                showStatus(areaStatusDiv, {{ _("Saving area definition...")|tojson }}, false);
                // csrfTokenMeta is now in scope as this block is inside DOMContentLoaded
                const csrfToken = csrfTokenMeta ? csrfTokenMeta.getAttribute('content') : document.querySelector('input[name="csrf_token"]')?.value;

                try {
                    const payloadForResourceUpdate = {
                        floor_map_id: floorMapId,
                        map_coordinates: areaData.coordinates,
                        booking_restriction: areaData.booking_restriction,
                    };

                    const response = await fetch(`/api/admin/resources/${targetResourceId}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': csrfToken
                        },
                        body: JSON.stringify(payloadForResourceUpdate)
                    });
                    const result = await response.json();
                    if (!response.ok) {
                        throw new Error(result.error || `HTTP error! status: ${response.status}`);
                    }
                    showStatus(areaStatusDiv, result.message || {{ _("Area definition saved successfully!")|tojson }}, false);

                    if (typeof window.fetchAndDrawExistingMapAreas === 'function') {
                        window.fetchAndDrawExistingMapAreas(floorMapId);
                    }
                    document.getElementById('define-area-form').reset();
                    populateDefineAreaRolesCheckboxes(); // Call the renamed function
                } catch (error) {
                    console.error('Error saving area definition:', error);
                    const saveErrorMsgBase = {{ _("Error saving area definition: %s")|tojson }};
                    const saveErrorMsg = saveErrorMsgBase.replace('%s', error.message);
                    showStatus(areaStatusDiv, saveErrorMsg, true);
                }
            });
        }

        // Modify window.populateAreaForm to handle `allowed_role_ids` (Moved into DOMContentLoaded)
        const originalPopulateAreaForm = window.populateAreaForm;
        window.populateAreaForm = function(area, resourceId) {
            if (originalPopulateAreaForm) {
                originalPopulateAreaForm(area, resourceId);
            } else {
                document.getElementById('coord-x').value = area.x || '';
                document.getElementById('coord-y').value = area.y || '';
                document.getElementById('coord-width').value = area.width || '';
                document.getElementById('coord-height').value = area.height || '';
                document.getElementById('resource-to-map').value = resourceId || '';
            }
            const selectedRoleIds = area.allowed_role_ids || [];
            populateDefineAreaRolesCheckboxes(selectedRoleIds); // Call the renamed function
        };

    }); // End of DOMContentLoaded

    // The problematic duplicated selectMapBtnHandler and its listener are removed from here.
</script>
{% endblock %}
